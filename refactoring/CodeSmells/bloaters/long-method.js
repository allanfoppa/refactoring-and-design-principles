// NOTE: INITIAL CODE GENERATED BY AI AND REFACTORED BY ME

// Before Refactoring: Long Method
function calculateOrderTotalLongMethod(order) {
    let total = 0;

    // Calculate item total
    for (let item of order.items) {
        total += item.price * item.quantity;
    }

    // Apply discount
    if (order.discountCode) {
        if (order.discountCode === 'SUMMER10') {
            total *= 0.9; // 10% discount
        } else if (order.discountCode === 'WINTER20') {
            total *= 0.8; // 20% discount
        }
    }

    // Add shipping cost
    if (order.shippingMethod === 'express') {
        total += 15;
    } else {
        total += 5;
    }

    return total;
}

// After Refactoring: Extracted Methods
function calculateOrderTotalExtractedMethods(order) {
    const itemTotal = calculateItemTotal(order.items);
    const discountedTotal = applyDiscount(itemTotal, order.discountCode);
    return addShippingCost(discountedTotal, order.shippingMethod);
}

function calculateItemTotal(items) {
    return items.reduce((total, item) => total + item.price * item.quantity, 0);
}

function applyDiscount(total, discountCode) {
    switch (discountCode) {
        case 'SUMMER10':
            return total * 0.9; // 10% discount
        case 'WINTER20':
            return total * 0.8; // 20% discount
        default:
            return total;
    }
}

function addShippingCost(total, shippingMethod) {
    return total + (shippingMethod === 'express' ? 15 : 5);
}

// FINAL NOTE:
// - Using this approach makes the code more readable and maintainable.
// - Each method has a single responsibility, making it easier to understand, add new code and modify in the future.