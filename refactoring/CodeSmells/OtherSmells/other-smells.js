// NOTE: EXAMPLE GENERATED BY AI

// Before Refactoring: Incomplete Library Class
// The library class does not provide the functionality we need, and we cannot modify it directly.
class LibraryClass {
  constructor(data) {
    this.data = data;
  }

  getData() {
    return this.data;
  }
}

// We need a method to transform the data, but the library does not provide it.
// So, we end up duplicating code or writing workarounds in multiple places.
function processData(libraryInstance) {
  const data = libraryInstance.getData();
  return data.toUpperCase(); // Example transformation
}

const libraryInstance = new LibraryClass("example");
console.log(processData(libraryInstance)); // Output: EXAMPLE

// After Refactoring: Introduce Local Extension
// We create a local extension to add the missing functionality.
// This way, we can change the behavior of the library class without modifying it directly.
class ExtendedLibraryClass extends LibraryClass {
  transformData() {
    return this.getData().toUpperCase(); // Example transformation
  }
}

const extendedLibraryInstance = new ExtendedLibraryClass("example");
console.log(extendedLibraryInstance.transformData()); // Output: EXAMPLE
