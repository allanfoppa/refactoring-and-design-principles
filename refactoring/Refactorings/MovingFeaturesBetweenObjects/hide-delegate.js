// NOTE: CODE GENERATED BY AI

/*
Hide Delegate Example

Problem:
The client gets object B from a field or method of object A. Then the client calls a method of object B.

Solution:
Create a new method in class A that delegates the call to object B. Now the client doesnâ€™t know about, or depend on, class B.
*/

// =====================
// Hide Delegate - Before
// =====================

class Department {
  constructor(manager) {
    this._manager = manager;
  }
  get manager() {
    return this._manager;
  }
}

class Person {
  constructor(name, department) {
    this._name = name;
    this._department = department;
  }
  get department() {
    return this._department;
  }
}

// Client code
const manager = new Person("Allan", null);
const department = new Department(manager);
const person = new Person("Bernardo", department);

// Client wants to get the manager of a person
const managerOfPerson = person.department.manager;
console.log(managerOfPerson._name); // Allan

// =====================
// Hide Delegate - After
// =====================

class Department2 {
  constructor(manager) {
    this._manager = manager;
  }
  get manager() {
    return this._manager;
  }
}

class Person2 {
  constructor(name, department) {
    this._name = name;
    this._department = department;
  }
  // Hide Delegate: Add a delegating method
  get manager() {
    return this._department.manager;
  }
}

// Client code
const manager2 = new Person2("Allan", null);
const department2 = new Department2(manager2);
const person2 = new Person2("Bernardo", department2);

// Client now calls person2.manager directly, not knowing about Department2
const managerOfPerson2 = person2.manager;
console.log(managerOfPerson2._name); // Allan

// FINAL NOTE:
// - Hides delegation from the client.
// - Reduces coupling between client and delegate classes.
// - Makes future changes easier.
